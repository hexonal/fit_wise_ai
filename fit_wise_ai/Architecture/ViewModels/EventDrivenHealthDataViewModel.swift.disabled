//
//  EventDrivenHealthDataViewModel.swift
//  fit_wise_ai
//
//  Created by AI on 2025/8/24.
//

import Foundation
import SwiftUI
import Combine
import OSLog

/**
 * äº‹ä»¶é©±åŠ¨çš„å¥åº·æ•°æ®è§†å›¾æ¨¡å‹
 * 
 * é‡æ„åçš„ViewModelï¼Œå®Œå…¨åŸºäºäº‹ä»¶é©±åŠ¨æ¶æ„ï¼š
 * - é€šè¿‡äº‹ä»¶ä¸Actorç³»ç»Ÿäº¤äº’
 * - è®¢é˜…äº‹ä»¶æµæ›´æ–°UIçŠ¶æ€
 * - æä¾›å“åº”å¼çš„ç”¨æˆ·ç•Œé¢ç»‘å®š
 * - æ”¯æŒçŠ¶æ€å›æ”¾å’Œè°ƒè¯•
 */
@MainActor
class EventDrivenHealthDataViewModel: ObservableObject {
    
    // MARK: - Published Properties
    
    /// å¥åº·æ•°æ®çŠ¶æ€
    @Published private(set) var healthData: HealthData = HealthData()
    /// å†å²å¥åº·æ•°æ®ï¼ˆ7å¤©ï¼‰
    @Published private(set) var weeklyHealthData: [HealthData] = []
    /// AIå»ºè®®åˆ—è¡¨
    @Published private(set) var aiAdvice: [AIAdvice] = []
    /// åŠ è½½çŠ¶æ€
    @Published private(set) var isLoading = false
    /// HealthKitæˆæƒçŠ¶æ€
    @Published private(set) var isHealthKitAuthorized = false
    /// AIæœåŠ¡çŠ¶æ€
    @Published private(set) var isAIServiceReady = false
    /// é”™è¯¯çŠ¶æ€
    @Published private(set) var currentError: AppError?
    /// æƒé™æ‹’ç»æç¤º
    @Published var showingPermissionAlert = false
    /// ç³»ç»ŸçŠ¶æ€æ‘˜è¦
    @Published private(set) var systemStatus: SystemStatus = SystemStatus()
    
    // MARK: - Private Properties
    
    /// äº‹ä»¶é©±åŠ¨çš„å¥åº·æœåŠ¡
    private let healthService = EventDrivenHealthKitService()
    /// äº‹ä»¶é©±åŠ¨çš„AIæœåŠ¡
    private let aiService = EventDrivenAIService()
    /// äº‹ä»¶æ€»çº¿å¼•ç”¨
    private let eventBus = EventBus.shared
    /// Actorç³»ç»Ÿå¼•ç”¨
    private let actorSystem = ActorSystem.shared
    /// æ—¥å¿—è®°å½•å™¨
    private let logger = Logger(subsystem: "fit_wise_ai", category: "EventDrivenHealthDataViewModel")
    /// å–æ¶ˆè®¢é˜…é›†åˆ
    private var cancellables = Set<AnyCancellable>()
    /// äº‹ä»¶æµè®¢é˜…
    private var eventSubscriptions = Set<AnyCancellable>()
    
    // MARK: - Initialization
    
    init() {
        logger.info("EventDrivenHealthDataViewModel initializing")
        setupServiceBindings()
        setupEventSubscriptions()
        initializeServices()
    }
    
    deinit {
        logger.info("EventDrivenHealthDataViewModel deinitialized")
    }
    
    // MARK: - Service Initialization
    
    private func initializeServices() {
        Task {
            // æœåŠ¡ä¼šè‡ªåŠ¨åˆå§‹åŒ–ï¼Œæˆ‘ä»¬åªéœ€è¦ç­‰å¾…çŠ¶æ€æ›´æ–°
            logger.info("Services initializing automatically")
        }
    }
    
    // MARK: - Service Bindings
    
    private func setupServiceBindings() {
        // ç»‘å®šå¥åº·æœåŠ¡çŠ¶æ€
        healthService.$currentState
            .map { state in
                switch state {
                case .authorized: return true
                default: return false
                }
            }
            .assign(to: &$isHealthKitAuthorized)
        
        healthService.$latestHealthData
            .compactMap { $0?.toHealthData() }
            .assign(to: &$healthData)
        
        // ç»‘å®šAIæœåŠ¡çŠ¶æ€
        aiService.$currentState
            .map { state in
                switch state {
                case .ready: return true
                default: return false
                }
            }
            .assign(to: &$isAIServiceReady)
        
        aiService.$latestAdvice
            .map { snapshots in
                snapshots.compactMap { $0.toAIAdvice() }
            }
            .assign(to: &$aiAdvice)
        
        // åˆå¹¶åŠ è½½çŠ¶æ€
        Publishers.CombineLatest(
            healthService.$currentState,
            aiService.$currentState
        )
        .map { healthState, aiState in
            switch (healthState, aiState) {
            case (.fetchingData, _), (_, .generating):
                return true
            case (.requestingPermissions, _), (.initializing, _), (_, .initializing):
                return true
            default:
                return false
            }
        }
        .assign(to: &$isLoading)
        
        logger.info("Service bindings established")
    }
    
    // MARK: - Event Subscriptions
    
    private func setupEventSubscriptions() {
        // è®¢é˜…å¥åº·æ•°æ®æ›´æ–°äº‹ä»¶
        eventBus.eventPublisher(for: HealthDataUpdatedEvent.self)
            .sink { [weak self] event in
                self?.handleHealthDataUpdated(event)
            }
            .store(in: &eventSubscriptions)
        
        // è®¢é˜…AIå»ºè®®ç”Ÿæˆäº‹ä»¶
        eventBus.eventPublisher(for: AIAdviceGeneratedEvent.self)
            .sink { [weak self] event in
                self?.handleAIAdviceGenerated(event)
            }
            .store(in: &eventSubscriptions)
        
        // è®¢é˜…æƒé™æ‹’ç»äº‹ä»¶
        eventBus.eventPublisher(for: HealthPermissionDeniedEvent.self)
            .sink { [weak self] event in
                self?.handlePermissionDenied(event)
            }
            .store(in: &eventSubscriptions)
        
        // è®¢é˜…é”™è¯¯äº‹ä»¶
        eventBus.subscribeToAll { [weak self] event in
            await self?.handleGenericEvent(event)
            return .success
        }
        
        logger.info("Event subscriptions established")
    }
    
    // MARK: - Public Interface
    
    /**
     * è¯·æ±‚HealthKitæƒé™
     */
    func requestHealthKitPermission() async {
        logger.info("Requesting HealthKit permission")
        
        let success = await healthService.requestAuthorization()
        
        if success {
            logger.info("HealthKit permission granted, refreshing data")
            await refreshAllData()
        } else {
            logger.warning("HealthKit permission denied")
            showingPermissionAlert = true
            currentError = AppError.permissionDenied("HealthKitæƒé™è¢«æ‹’ç»")
        }
    }
    
    /**
     * åˆ·æ–°æ‰€æœ‰æ•°æ®
     */
    func refreshAllData() async {
        logger.info("Refreshing all data")
        
        guard isHealthKitAuthorized else {
            logger.warning("Cannot refresh data: HealthKit not authorized")
            await requestHealthKitPermission()
            return
        }
        
        // å¹¶å‘è·å–ä»Šæ—¥æ•°æ®å’Œå†å²æ•°æ®
        async let todayData = healthService.fetchTodayHealthData()
        async let historicalData = fetchWeeklyData()
        
        // ç­‰å¾…æ•°æ®è·å–å®Œæˆ
        let (today, weekly) = await (todayData, historicalData)
        
        if let todaySnapshot = today {
            healthData = todaySnapshot.toHealthData()
        }
        
        weeklyHealthData = weekly
        
        // åŸºäºå¥åº·æ•°æ®ç”ŸæˆAIå»ºè®®
        if !weeklyHealthData.isEmpty {
            await generateAIAdvice()
        }
        
        // æ›´æ–°ç³»ç»ŸçŠ¶æ€
        await updateSystemStatus()
        
        logger.info("All data refreshed successfully")
    }
    
    /**
     * ç”ŸæˆAIå»ºè®®
     */
    func generateAIAdvice() async {
        logger.info("Generating AI advice")
        
        guard isAIServiceReady else {
            logger.warning("AI service not ready")
            currentError = AppError.serviceUnavailable("AIæœåŠ¡æš‚ä¸å¯ç”¨")
            return
        }
        
        let advice = await aiService.generateAdvice(from: healthData)
        
        if advice.isEmpty {
            logger.warning("No AI advice generated")
            currentError = AppError.dataProcessingFailed("AIå»ºè®®ç”Ÿæˆå¤±è´¥")
        } else {
            logger.info("AI advice generated: \(advice.count) pieces")
            clearError()
        }
    }
    
    /**
     * ç”Ÿæˆå‘¨å»ºè®®
     */
    func generateWeeklyAdvice() async {
        logger.info("Generating weekly AI advice")
        
        guard isAIServiceReady && !weeklyHealthData.isEmpty else {
            logger.warning("Cannot generate weekly advice: service not ready or no data")
            return
        }
        
        let advice = await aiService.generateWeeklyAdvice(from: weeklyHealthData)
        
        if !advice.isEmpty {
            logger.info("Weekly AI advice generated: \(advice.count) pieces")
        }
    }
    
    /**
     * è®¾ç½®å¥åº·ç›®æ ‡
     */
    func setHealthGoal(type: String, targetValue: Double, timeFrame: String) async -> Bool {
        logger.info("Setting health goal: \(type) = \(targetValue)")
        
        let success = await healthService.setHealthGoal(
            type: type,
            targetValue: targetValue,
            timeFrame: timeFrame
        )
        
        if success {
            logger.info("Health goal set successfully")
            // é‡æ–°æ£€æŸ¥ç›®æ ‡çŠ¶æ€
            await checkHealthGoals()
        } else {
            logger.error("Failed to set health goal")
            currentError = AppError.operationFailed("å¥åº·ç›®æ ‡è®¾ç½®å¤±è´¥")
        }
        
        return success
    }
    
    /**
     * æ£€æŸ¥å¥åº·ç›®æ ‡
     */
    func checkHealthGoals() async {
        logger.info("Checking health goals")
        
        let goalTypes = ["steps", "calories", "workout"]
        
        for goalType in goalTypes {
            let result = await healthService.checkHealthGoal(goalType)
            if result {
                    logger.info("Health goal achieved: \(goalType)")
                    // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºç¥è´ºæ¶ˆæ¯æˆ–å‘é€é€šçŸ¥
                }
            }
        }
    }
    
    /**
     * è¯„ä¼°AIå»ºè®®è´¨é‡
     */
    func evaluateAdviceQuality(adviceId: UUID, feedback: String, rating: Int) async {
        logger.info("Evaluating advice quality: \(adviceId)")
        
        let success = await aiService.evaluateAdviceQuality(
            adviceId: adviceId,
            feedback: feedback,
            rating: rating
        )
        
        if success {
            logger.info("Advice quality evaluation recorded")
        } else {
            logger.error("Failed to record advice quality evaluation")
        }
    }
    
    /**
     * è·å–ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š
     */
    func getDiagnosticsReport() async -> String {
        logger.info("Generating diagnostics report")
        
        var report = "ğŸ¥ FitWise AI ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š\n"
        report += "ç”Ÿæˆæ—¶é—´: \(DateFormatter.localizedString(from: Date(), dateStyle: .medium, timeStyle: .medium))\n\n"
        
        // HealthKitæœåŠ¡è¯Šæ–­
        let healthDiagnostics = await healthService.performDiagnostics()
        report += healthDiagnostics + "\n"
        
        // AIæœåŠ¡è¯Šæ–­
        let aiDiagnostics = await aiService.performDiagnostics()
        report += aiDiagnostics + "\n"
        
        // Actorç³»ç»Ÿç»Ÿè®¡
        let actorStats = actorSystem.getSystemStatistics()
        report += "ğŸ­ Actorç³»ç»Ÿç»Ÿè®¡\n"
        report += "   æ€»Actoræ•°é‡: \(actorStats["totalActors"] ?? 0)\n"
        if let actors = actorStats["actors"] as? [String: Any] {
            for (name, stats) in actors {
                if let actorStats = stats as? [String: Any] {
                    report += "   \(name): å¤„ç†äº†\(actorStats["messagesProcessed"] ?? 0)æ¡æ¶ˆæ¯\n"
                }
            }
        }
        report += "\n"
        
        // äº‹ä»¶ç³»ç»Ÿç»Ÿè®¡
        let eventStats = await EventStore.shared.getEventStatistics()
        report += "ğŸ“Š äº‹ä»¶å­˜å‚¨ç»Ÿè®¡\n"
        report += "   æ€»äº‹ä»¶æ•°: \(eventStats.totalEvents)\n"
        report += "   äº‹ä»¶ç±»å‹: \(eventStats.eventTypeCount.count)\n"
        if let timeSpan = eventStats.timeSpan {
            report += "   æ—¶é—´è·¨åº¦: \(String(format: "%.1f", timeSpan / 3600))å°æ—¶\n"
        }
        
        return report
    }
    
    // MARK: - Event Handlers
    
    private func handleHealthDataUpdated(_ event: HealthDataUpdatedEvent) {
        logger.info("Health data updated event received")
        
        // æ•°æ®ä¼šé€šè¿‡service bindingè‡ªåŠ¨æ›´æ–°
        // è¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„å¤„ç†é€»è¾‘
        
        // æ¸…é™¤ä»»ä½•ç›¸å…³é”™è¯¯
        if case .dataProcessingFailed = currentError {
            clearError()
        }
    }
    
    private func handleAIAdviceGenerated(_ event: AIAdviceGeneratedEvent) {
        logger.info("AI advice generated event received: \(event.generatedAdvice.count) pieces")
        
        // å»ºè®®ä¼šé€šè¿‡service bindingè‡ªåŠ¨æ›´æ–°
        // è¿™é‡Œå¯ä»¥æ·»åŠ æˆåŠŸé€šçŸ¥æˆ–å…¶ä»–UIåé¦ˆ
        
        // æ¸…é™¤AIç›¸å…³é”™è¯¯
        if case .serviceUnavailable = currentError {
            clearError()
        }
    }
    
    private func handlePermissionDenied(_ event: HealthPermissionDeniedEvent) {
        logger.warning("Health permission denied event received")
        
        showingPermissionAlert = true
        currentError = AppError.permissionDenied("éœ€è¦å¥åº·æ•°æ®æƒé™æ‰èƒ½æä¾›ä¸ªæ€§åŒ–å»ºè®®")
    }
    
    private func handleGenericEvent(_ event: any BaseEvent) async {
        // å¤„ç†é€šç”¨äº‹ä»¶ï¼Œä¸»è¦ç”¨äºè°ƒè¯•å’Œç›‘æ§
        if event.eventType.contains("Failed") || event.eventType.contains("Error") {
            logger.error("Error event received: \(event.eventType) from \(event.source)")
            
            // æ ¹æ®äº‹ä»¶ç±»å‹è®¾ç½®ç›¸åº”çš„é”™è¯¯çŠ¶æ€
            if event.source.contains("Health") {
                currentError = AppError.dataProcessingFailed("å¥åº·æ•°æ®å¤„ç†å¤±è´¥")
            } else if event.source.contains("AI") {
                currentError = AppError.serviceUnavailable("AIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func fetchWeeklyData() async -> [HealthData] {
        let endDate = Date()
        let startDate = Calendar.current.date(byAdding: .day, value: -7, to: endDate)!
        let dateRange = DateInterval(start: startDate, end: endDate)
        
        let snapshots = await healthService.fetchHistoricalHealthData(dateRange: dateRange)
        return snapshots.map { $0.toHealthData() }
    }
    
    private func updateSystemStatus() async {
        let healthStatus = healthService.getStatusReport()
        let aiStatus = aiService.getStatusReport()
        
        systemStatus = SystemStatus(
            isHealthKitHealthy: healthStatus.isHealthy,
            isAIServiceHealthy: aiStatus.isHealthy,
            hasRecentHealthData: healthStatus.hasValidData,
            hasRecentAIAdvice: aiStatus.hasRecentAdvice,
            lastUpdated: Date()
        )
    }
    
    private func clearError() {
        currentError = nil
    }
    
    // MARK: - Development and Testing Methods
    
    #if DEBUG
    /**
     * æ¨¡æ‹Ÿå¥åº·æ•°æ®æ›´æ–°ï¼ˆä»…ç”¨äºå¼€å‘æµ‹è¯•ï¼‰
     */
    func simulateHealthDataUpdate() async {
        logger.info("Simulating health data update for testing")
        
        let mockHealthData = HealthData(
            steps: Int.random(in: 5000...15000),
            heartRate: Double.random(in: 60...100),
            activeEnergyBurned: Double.random(in: 200...800),
            workoutTime: Double.random(in: 0...7200),
            distanceWalkingRunning: Double.random(in: 1000...10000)
        )
        
        healthData = mockHealthData
        
        // å‘å¸ƒæ¨¡æ‹Ÿäº‹ä»¶
        await eventBus.publish(HealthDataUpdatedEvent(
            previousData: nil,
            currentData: HealthDataSnapshot(from: mockHealthData),
            changedFields: ["steps", "heartRate", "activeEnergyBurned"],
            source: "SimulationService"
        ))
    }
    
    /**
     * è§¦å‘é”™è¯¯çŠ¶æ€ï¼ˆä»…ç”¨äºå¼€å‘æµ‹è¯•ï¼‰
     */
    func simulateError(_ error: AppError) {
        logger.info("Simulating error for testing: \(error)")
        currentError = error
    }
    #endif

// MARK: - Supporting Types

/**
 * åº”ç”¨é”™è¯¯ç±»å‹
 */
enum AppError: Error, LocalizedError, Equatable {
    case permissionDenied(String)
    case serviceUnavailable(String)
    case dataProcessingFailed(String)
    case networkError(String)
    case operationFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .permissionDenied(let message),
             .serviceUnavailable(let message),
             .dataProcessingFailed(let message),
             .networkError(let message),
             .operationFailed(let message):
            return message
        }
    }
    
    var icon: String {
        switch self {
        case .permissionDenied: return "exclamationmark.shield"
        case .serviceUnavailable: return "cloud.slash"
        case .dataProcessingFailed: return "exclamationmark.triangle"
        case .networkError: return "wifi.slash"
        case .operationFailed: return "xmark.circle"
        }
    }
}

/**
 * ç³»ç»ŸçŠ¶æ€æ‘˜è¦
 */
struct SystemStatus {
    var isHealthKitHealthy: Bool = false
    var isAIServiceHealthy: Bool = false
    var hasRecentHealthData: Bool = false
    var hasRecentAIAdvice: Bool = false
    var lastUpdated: Date = Date()
    
    var overallHealth: SystemHealth {
        if isHealthKitHealthy && isAIServiceHealthy && hasRecentHealthData {
            return .excellent
        } else if isHealthKitHealthy && (isAIServiceHealthy || hasRecentHealthData) {
            return .good
        } else if isHealthKitHealthy || isAIServiceHealthy {
            return .fair
        } else {
            return .poor
        }
    }
}

enum SystemHealth: String, CaseIterable {
    case excellent = "ä¼˜ç§€"
    case good = "è‰¯å¥½"
    case fair = "ä¸€èˆ¬"
    case poor = "è¾ƒå·®"
    
    var color: String {
        switch self {
        case .excellent: return "appGreen"
        case .good: return "appBlue"
        case .fair: return "appOrange"
        case .poor: return "appPurple"
        }
    }
    
    var icon: String {
        switch self {
        case .excellent: return "checkmark.circle.fill"
        case .good: return "checkmark.circle"
        case .fair: return "exclamationmark.circle"
        case .poor: return "xmark.circle"
        }
    }
}